import {
  BehaviorSubject,
  distinctUntilChanged,
  map,
  Observable,
  of,
  shareReplay,
  Subject,
  Subscription
} from 'rxjs';
import { DestroyRef, Injectable } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';


/**
 * `RxJsStore` this abstract class allows to transform a service into a local store.
 *  It contains all the functions needed to manage the state and also contains a
 *  function to execute actions or side effects with RxJs.
 *
 *  This class can be used by inheriting it in your service and then initializing it
 *  in the constructor using the `super()` function.
 */
export abstract class RxjsStore<TState extends object> {

  /* Behavior Subject that contains all the state of the store */
  private readonly state: BehaviorSubject<TState>;

  /* Observable to listen to all changes of the store.  */
  public readonly state$: Observable<TState>;

  /* Destroy Reference to unsubscribe to all the subscriptions generated by the executed actions. */
  private destroyRef: DestroyRef;

  /**
   * RxJs Store constructor
   * @param initialState - Initial values that the store will start with
   * @param destroyRef - `DestroyRef` of the service, this is needed to unsubscribe from all the actions when
   * the component is destroyed.
   * @protected
   */
  protected constructor(initialState: TState, destroyRef: DestroyRef) {
    this.state = new BehaviorSubject<TState>(initialState);
    this.state$ = this.state.asObservable().pipe(shareReplay(1))
    this.destroyRef = destroyRef;
  }

  /* Gets imperatively the value of the store's state. */
  public getCurrentValue(): TState {
    return this.state.value;
  }

  /* Update the whole state of the store. */
  public update(newValue: TState): void {
    this.state.next(newValue);
  }

  /* Updates partially the state of the store. */
  public patch(newPartialValue: Partial<TState>): void {
    this.state.next({...this.state.value, ...newPartialValue})
  }

  /**
   * Selects a fraction of the store's state.
   * @example isLoading$ = this.select(s => s.isLoading);
   * @param callback - Callback function to select certain attributes from the state object.
   * @returns An observable with the fraction selected, this observable will only emit when one of the selected
   * values has been changed.
   */
  public select<TSelected>(callback: (arg: TState) => TSelected): Observable<TSelected> {
    return this.state$.pipe(
      map(callback),
      distinctUntilChanged()
    )
  }

  /**
   * Executes an observable chain and manages its subscription. Allows to execute actions or side effects
   * in a declarative way without implicitly subscribing.
   * @example
   * findPost(postId: number) {
   *     this.action<number>(id$ =>
   *       id$.pipe(
   *         tap(() => this.patch({isLoading: true})),
   *         switchMap((id) => this.findPostHttp().pipe(
   *           tap(() => this.patch({isLoading: false})),
   *           catchError(err => {
   *             console.error(err);
   *             return EMPTY;
   *           }),
   *           tap({
   *             next: (res) => this.patch({selectedPost: res.title})
   *           })
   *         ))
   *       )
   *     )(postId);
   *   }
   *
   * @param chain - Observable chain to be executed.
   * @returns - Returns a function that will execute the observable chain.
   */
  public action<TPayload>(chain: (payload$: Observable<TPayload>) => Observable<unknown>) {
    const sub = new Subject<TPayload>();
    chain(sub).pipe(takeUntilDestroyed(this.destroyRef)).subscribe();

    return (payload: TPayload): Subscription =>
      of(payload).pipe(takeUntilDestroyed(this.destroyRef)).subscribe(value => sub.next(value))
  }
}
